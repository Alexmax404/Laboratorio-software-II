-- Eliminar tablas
	DROP TABLE IF EXISTS gtg.evaluacion_coordinador CASCADE;
	DROP TABLE IF EXISTS gtg.formato_version CASCADE;
	DROP TABLE IF EXISTS gtg.formato CASCADE;
	DROP TABLE IF EXISTS gtg.usuario CASCADE;
	
	-- Eliminar funciones
	DROP FUNCTION IF EXISTS gtg.fn_get_latest_version(UUID);
	
	DROP FUNCTION IF EXISTS gtg.submit_formato(
	    UUID, UUID, UUID, UUID, UUID, TEXT, TEXT, TEXT, TEXT, DATE, TEXT, TEXT, TEXT, TEXT,
	    OUT UUID, OUT INTEGER
	);
	
	DROP FUNCTION IF EXISTS gtg.add_evaluacion_coordinador(
	    UUID, UUID, UUID, TEXT, TEXT,
	    OUT UUID
	); 
	
	--Eliminar indices 
	DROP INDEX IF EXISTS gtg.idx_usuario_correo;
	DROP INDEX IF EXISTS gtg.idx_formato_est1;
	DROP INDEX IF EXISTS gtg.idx_formato_est2;
	DROP INDEX IF EXISTS gtg.idx_formato_doc;
	DROP INDEX IF EXISTS gtg.idx_formato_estado;
	DROP INDEX IF EXISTS gtg.idx_formato_version_formato;
	DROP INDEX IF EXISTS gtg.idx_formato_version_formato_version;
	DROP INDEX IF EXISTS gtg.idx_eval_formato;
	DROP INDEX IF EXISTS gtg.idx_eval_coordinador_coordinador;
	
	-- Limpiar tablas
	TRUNCATE TABLE gtg.evaluacion_coordinador RESTART IDENTITY CASCADE;
	TRUNCATE TABLE gtg.formato_version RESTART IDENTITY CASCADE;
	TRUNCATE TABLE gtg.formato RESTART IDENTITY CASCADE;
	TRUNCATE TABLE gtg.usuario RESTART IDENTITY CASCADE;
	
	-- ===============================================
	-- USUARIOS Y BASE DE DATOS GTG
	-- ===============================================
	
	-- Rol dueño de la BD (solo para DDL, no para la app)
	CREATE ROLE gtg_owner LOGIN PASSWORD 'AdminPass2025!' CREATEDB;
	
	-- Base de datos principal
	CREATE DATABASE gestiontg OWNER gtg_owner;
	
	-- Rol de la aplicación (solo DML)
	CREATE ROLE gtg_appuser LOGIN PASSWORD 'ApplicationUser2025!';
	
	CREATE SCHEMA IF NOT EXISTS gtg AUTHORIZATION gtg_owner;
	
	-- Extensiones
	CREATE EXTENSION IF NOT EXISTS pgcrypto;
	
	-- ===============================================
	-- ASIGNACIÓN DE PRIVILEGIOS AL USUARIO DE LA APP
	-- ===============================================
	GRANT CONNECT ON DATABASE gestiontg TO gtg_appuser;   -- acceso a la BD
	GRANT USAGE ON SCHEMA public TO gtg_appuser;          -- uso de esquema public
	GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO gtg_appuser; -- DML
	ALTER DEFAULT PRIVILEGES IN SCHEMA public
	GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO gtg_appuser;
	
	-- Conceder acceso al esquema gtg
	GRANT USAGE ON SCHEMA gtg TO gtg_appuser;
	
	-- Conceder permisos sobre todas las tablas del esquema gtg
	GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA gtg TO gtg_appuser;
	
	-- Asegurar permisos para tablas futuras
	ALTER DEFAULT PRIVILEGES IN SCHEMA gtg 
	GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO gtg_appuser;
	
	-- Conceder permisos para usar las secuencias (necesario para inserciones con DEFAULT)
	GRANT USAGE ON ALL SEQUENCES IN SCHEMA gtg TO gtg_appuser;
	ALTER DEFAULT PRIVILEGES IN SCHEMA gtg 
	GRANT USAGE ON SEQUENCES TO gtg_appuser;
	
	-- ===============================================
	-- CREACIÓN DE TABLAS
	-- ===============================================
	
	-- USUARIO (docentes, estudiantes, coordinadores)
	CREATE TABLE IF NOT EXISTS gtg.usuario (
	    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- Estaba usando UUID, si resulta cansón lo podemos cambiar.
	    nombres TEXT NOT NULL,
	    apellidos TEXT NOT NULL,
	    celular TEXT,
	    programa TEXT NOT NULL CHECK (programa IN 
	        ('IngenieriaDeSistemas', 
	         'IngenieriaElectronicaYTelecomunicaciones', 
	         'AutomaticaIndustrial', 
	         'TecnologiaIndustrial')),
	    rol TEXT NOT NULL CHECK (rol IN ('Docente', 'Estudiante', 'Coordinador')),
	    correo TEXT UNIQUE NOT NULL,
	    contrasenia TEXT NOT NULL
	);
	
	CREATE INDEX IF NOT EXISTS idx_usuario_correo ON gtg.usuario(correo);
	
	-- FORMATO A (Tabla maestra de formato A (Id dijo por cada formato))
	CREATE TABLE IF NOT EXISTS gtg.formato (
	    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	    estudiante_id1 UUID NOT NULL REFERENCES gtg.usuario(id) ON DELETE CASCADE,
		estudiante_id2 UUID	NULL REFERENCES gtg.usuario(id) ON DELETE SET NULL, --- Cambiar esto
		docente_id UUID NOT NULL REFERENCES gtg.usuario(id) ON DELETE CASCADE,
	    titulo TEXT NOT NULL,
	    modalidad TEXT NOT NULL,
	    director TEXT NOT NULL,
	    co_director TEXT,
	    fecha_presentacion DATE NOT NULL,
	    estado TEXT NOT NULL CHECK (estado IN (
	        'En_Revision', 'Aprobado', 'Rechazado', 'Correcciones'
	    )) DEFAULT 'En_Revision',
	    intentos INTEGER NOT NULL DEFAULT 0,    -- número de envíos (se controla con funciones)
	    max_intentos INTEGER NOT NULL DEFAULT 3,
	    created_at TIMESTAMPTZ DEFAULT now(),
	    updated_at TIMESTAMPTZ DEFAULT now()
	);
	
	CREATE INDEX IF NOT EXISTS idx_formato_est1 ON gtg.formato(estudiante_id1);
	CREATE INDEX IF NOT EXISTS idx_formato_est2 ON gtg.formato(estudiante_id2);
	CREATE INDEX IF NOT EXISTS idx_formato_doc ON gtg.formato(docente_id);
	CREATE INDEX IF NOT EXISTS idx_formato_estado ON gtg.formato(estado);
	
	-- HISTORIAL DE VERSIONES (Cada reenvío genera una nueva fila)
	CREATE TABLE IF NOT EXISTS gtg.formato_version (
	    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	    formato_id UUID NOT NULL REFERENCES gtg.formato(id) ON DELETE CASCADE,
	    version INTEGER NOT NULL, 
	    titulo TEXT NOT NULL,
	    modalidad TEXT NOT NULL,
	    director TEXT NOT NULL,
	    co_director TEXT,
	    fecha_presentacion DATE NOT NULL,
	    objetivos_generales TEXT NOT NULL,
	    objetivos_especificos TEXT NOT NULL,
	    archivo_formato_path TEXT NOT NULL, -- ruta/URL al PDF
	    observaciones_estudiante TEXT,
	    estado_local TEXT NOT NULL CHECK (estado_local IN (
	        'En_Revision', 'Aprobado', 'Rechazado', 'Correcciones'
	    )) DEFAULT 'En_Revision',
	    enviado_por UUID NOT NULL REFERENCES gtg.usuario(id),
	    fecha_subida TIMESTAMPTZ DEFAULT now(),
	    UNIQUE (formato_id, version)
	);
	
	CREATE INDEX IF NOT EXISTS idx_formato_version_formato ON gtg.formato_version(formato_id);
	CREATE INDEX IF NOT EXISTS idx_formato_version_formato_version ON gtg.formato_version(formato_id, version DESC);
	
	-- EVALUACIÓN COORDINADOR
	CREATE TABLE IF NOT EXISTS gtg.evaluacion_coordinador (
	    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	    formato_id UUID NOT NULL REFERENCES gtg.formato(id) ON DELETE CASCADE,
	    formato_version_id UUID REFERENCES gtg.formato_version(id) ON DELETE SET NULL,
	    coordinador_id UUID NOT NULL REFERENCES gtg.usuario(id),
	    decision TEXT NOT NULL CHECK (decision IN ('Aprobado', 'Correcciones', 'Rechazado')),
	    comentarios TEXT,
	    fecha_evaluacion TIMESTAMPTZ DEFAULT now()
	);
	
	CREATE INDEX IF NOT EXISTS idx_eval_formato ON gtg.evaluacion_coordinador(formato_id);
	CREATE INDEX IF NOT EXISTS idx_eval_coordinador_coordinador ON gtg.evaluacion_coordinador(coordinador_id);
	
	-- ===========================================
	-- Función para obtener la última versión de un formato
	-- ===========================================
	CREATE OR REPLACE FUNCTION gtg.fn_get_latest_version(p_formato_id UUID)
	RETURNS INTEGER LANGUAGE sql STABLE AS $$
	  SELECT COALESCE(MAX(version), 0) FROM gtg.formato_version WHERE formato_id = p_formato_id;
	$$;
	
	-- ===========================================
	-- Función para "enviar/reenviar" Formato A (gestiona versión + intentos)
	--    - Si p_formato_id IS NULL -> crea formato maestro + version 1
	--    - Si p_formato_id IS NOT NULL -> crea nueva versión (version = last+1)
	--    - Bloquea si intentos >= max_intentos
	-- ===========================================
	CREATE OR REPLACE FUNCTION gtg.submit_formato(
    p_formato_id UUID,            -- NULL => crear nuevo
    p_estudiante_id1 UUID,
    p_estudiante_id2 UUID,
    p_docente_id UUID,
    p_enviado_por UUID,
    p_titulo TEXT,
    p_modalidad TEXT,
    p_director TEXT,
    p_co_director TEXT,
    p_fecha_presentacion DATE,
    p_objetivos_generales TEXT,
    p_objetivos_especificos TEXT,
    p_archivo_formato_path TEXT,
    OUT o_formato_id UUID,
    OUT o_version INTEGER
) RETURNS RECORD
LANGUAGE plpgsql AS $$
DECLARE
    v_formato gtg.formato%ROWTYPE;
    v_next_version INTEGER;
    v_new_intentos INTEGER;
    v_new_estado TEXT;
BEGIN
    IF p_formato_id IS NULL THEN
        -- ===== CREAR NUEVO FORMATO =====
        PERFORM 1 FROM gtg.usuario WHERE id = p_estudiante_id1;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Estudiante1 no existe';
        END IF;

        IF p_estudiante_id2 IS NOT NULL THEN
            PERFORM 1 FROM gtg.usuario WHERE id = p_estudiante_id2;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'Estudiante2 informado no existe';
            END IF;
        END IF;

        -- validación: estudiante1 no debe tener formatos en proceso
        PERFORM 1
        FROM gtg.formato f
        WHERE (f.estudiante_id1 = p_estudiante_id1 OR f.estudiante_id2 = p_estudiante_id1)
          AND f.estado IN ('En_Revision','Correcciones');
        IF FOUND THEN
            RAISE EXCEPTION 'El estudiante principal ya tiene un formato en proceso.';
        END IF;

        -- validación: estudiante2 (si existe) tampoco
        IF p_estudiante_id2 IS NOT NULL THEN
            PERFORM 1
            FROM gtg.formato f
            WHERE (f.estudiante_id1 = p_estudiante_id2 OR f.estudiante_id2 = p_estudiante_id2)
              AND f.estado IN ('En_Revision','Correcciones');
            IF FOUND THEN
                RAISE EXCEPTION 'El estudiante secundario ya tiene un formato en proceso.';
            END IF;
        END IF;

        -- validar que p_enviado_por sea el docente
        IF p_enviado_por IS NULL OR (p_enviado_por <> p_docente_id) THEN
            RAISE EXCEPTION 'El formato A debe ser enviado por el docente.';
        END IF;

        -- crear formato maestro (primer envío cuenta como intento = 1)
        INSERT INTO gtg.formato (
            estudiante_id1, estudiante_id2, docente_id,
            titulo, modalidad, director, co_director, fecha_presentacion,
            estado, intentos, max_intentos, created_at, updated_at
        )
        VALUES (
            p_estudiante_id1, p_estudiante_id2, p_docente_id,
            p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion,
            'En_Revision', 1, 3, now(), now()
        )
        RETURNING * INTO v_formato;

        v_next_version := 1;

        -- crear la versión 1; su estado_local reflejará el estado maestro ('En_Revision')
        INSERT INTO gtg.formato_version (
            formato_id, version, titulo, modalidad, director, co_director, fecha_presentacion,
            objetivos_generales, objetivos_especificos, archivo_formato_path, estado_local, enviado_por, fecha_subida
        )
        VALUES (
            v_formato.id, v_next_version, p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion,
            p_objetivos_generales, p_objetivos_especificos, p_archivo_formato_path, 'En_Revision', p_enviado_por, now()
        );

        o_formato_id := v_formato.id;
        o_version := v_next_version;
        RETURN;

    ELSE
        -- ===== REENVÍO =====
        -- Bloqueamos la fila para evitar condiciones de carrera
        SELECT * INTO v_formato
        FROM gtg.formato
        WHERE id = p_formato_id
        FOR UPDATE;

        IF NOT FOUND THEN
            RAISE EXCEPTION 'Formato % no encontrado', p_formato_id;
        END IF;

        -- validar que p_enviado_por sea el docente del formato
        IF p_enviado_por IS NULL OR (p_enviado_por <> v_formato.docente_id) THEN
            RAISE EXCEPTION 'Solo el docente propietario puede reenviar el formato.';
        END IF;

        -- bloquear si el estado no es Correcciones
        IF v_formato.estado <> 'Correcciones' THEN
            RAISE EXCEPTION 'El formato solo puede reenviarse cuando el estado es "Correcciones". Estado actual: %', v_formato.estado;
        END IF;

        -- si ya agotó intentos anteriormente, bloquear definitivamente
        IF v_formato.intentos >= v_formato.max_intentos THEN
            -- (garantizamos estado rechazado por seguridad)
            UPDATE gtg.formato
            SET estado = 'Rechazado', updated_at = now()
            WHERE id = p_formato_id;
            RAISE EXCEPTION 'El formato ya agotó el número máximo de intentos (%). No se permiten más reenvíos.', v_formato.max_intentos;
        END IF;

        -- calcular siguiente versión
        v_next_version := (SELECT COALESCE(MAX(version),0) + 1 FROM gtg.formato_version WHERE formato_id = p_formato_id);

        -- calcular nuevos intentos y nuevo estado SIN lanzar excepción (persistimos)
        v_new_intentos := v_formato.intentos + 1;
        IF v_new_intentos >= v_formato.max_intentos THEN
            v_new_estado := 'Rechazado';
        ELSE
            v_new_estado := 'En_Revision';
        END IF;

        -- insertar nueva versión; su estado_local reflejará el nuevo estado (rechazado o en revisión)
        INSERT INTO gtg.formato_version (
            formato_id, version, titulo, modalidad, director, co_director, fecha_presentacion,
            objetivos_generales, objetivos_especificos, archivo_formato_path, estado_local, enviado_por, fecha_subida
        )
        VALUES (
            p_formato_id, v_next_version, p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion,
            p_objetivos_generales, p_objetivos_especificos, p_archivo_formato_path, v_new_estado, p_enviado_por, now()
        );

        -- actualizar maestro con el nuevo conteo y estado (persistimos incluso si queda rechazado)
        UPDATE gtg.formato
        SET intentos = v_new_intentos,
            estado = v_new_estado,
            updated_at = now(),
            titulo = p_titulo,
            modalidad = p_modalidad,
            director = p_director,
            co_director = p_co_director,
            fecha_presentacion = p_fecha_presentacion
        WHERE id = p_formato_id
        RETURNING * INTO v_formato;

        -- si llegamos a rechazo, también actualizamos versiones previas en estado activo a 'Rechazado'
        IF v_new_estado = 'Rechazado' THEN
            UPDATE gtg.formato_version
            SET estado_local = 'Rechazado'
            WHERE formato_id = p_formato_id
              AND estado_local IN ('En_Revision','Correcciones');
            -- informamos al cliente (no rollback)
            RAISE NOTICE 'Se alcanzó el máximo de intentos (%). Formato y versiones marcadas como Rechazado.', v_formato.max_intentos;
        END IF;

        o_formato_id := v_formato.id;
        o_version := v_next_version;
        RETURN;
    END IF;
END;
$$;

	
	-- ===================================
	-- Función: add_evaluacion_coordinador (coordinador evalúa)
	-- ===================================
CREATE OR REPLACE FUNCTION gtg.add_evaluacion_coordinador(
    p_formato_id UUID,
    p_formato_version_id UUID,
    p_coordinador_id UUID,
    p_decision TEXT,
    p_comentarios TEXT,
    OUT o_eval_id UUID
) RETURNS UUID
LANGUAGE plpgsql AS $$
DECLARE
    v_rol TEXT;
    v_formato RECORD;
BEGIN
    -- validar rol del coordinador
    SELECT rol INTO v_rol FROM gtg.usuario WHERE id = p_coordinador_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Coordinador con id % no encontrado', p_coordinador_id;
    END IF;
    IF v_rol <> 'Coordinador' THEN
        RAISE EXCEPTION 'Usuario % no tiene rol Coordinador', p_coordinador_id;
    END IF;

    -- validar existencia del formato maestro
    SELECT * INTO v_formato FROM gtg.formato WHERE id = p_formato_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Formato % no existe', p_formato_id;
    END IF;

    -- ===== NUEVA VALIDACIÓN: bloquear evaluación si intentos agotados =====
    IF v_formato.intentos >= v_formato.max_intentos THEN
        RAISE EXCEPTION 'El formato ha agotado el número máximo de intentos (%). No se puede evaluar.', v_formato.max_intentos;
    END IF;

    -- si se pasó formato_version_id, validar que pertenezca al formato
    IF p_formato_version_id IS NOT NULL THEN
        PERFORM 1 FROM gtg.formato_version fv
        WHERE fv.id = p_formato_version_id AND fv.formato_id = p_formato_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'La versión % no pertenece al formato %', p_formato_version_id, p_formato_id;
        END IF;
    END IF;

    -- validar decisión permitida (seguridad extra)
    IF p_decision NOT IN ('Aprobado','Correcciones','Rechazado') THEN
        RAISE EXCEPTION 'Decision inválida: %', p_decision;
    END IF;

    -- insertar evaluación y devolver id en la variable OUT
    INSERT INTO gtg.evaluacion_coordinador (formato_id, formato_version_id, coordinador_id, decision, comentarios, fecha_evaluacion)
    VALUES (p_formato_id, p_formato_version_id, p_coordinador_id, p_decision, p_comentarios, now())
    RETURNING id INTO o_eval_id;

    -- actualizar estado del maestro según la decisión
    IF p_decision = 'Aprobado' THEN
        UPDATE gtg.formato SET estado = 'Aprobado', updated_at = now() WHERE id = p_formato_id;
    ELSIF p_decision = 'Rechazado' THEN
        UPDATE gtg.formato SET estado = 'Rechazado', updated_at = now() WHERE id = p_formato_id;
    ELSIF p_decision = 'Correcciones' THEN
        UPDATE gtg.formato SET estado = 'Correcciones', updated_at = now() WHERE id = p_formato_id;
    END IF;

    RETURN;  -- importante en funciones con OUT
END;
$$;
	
	-- ===============================================
	-- PRUEBAS
	-- ===============================================
	-- Estudiantes
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES 
	('Juan', 'Pérez', 'IngenieriaDeSistemas', 'Estudiante', 'juan@unicauca.edu.co', crypt('1234', gen_salt('bf'))),
	('Ana', 'López', 'IngenieriaDeSistemas', 'Estudiante', 'ana@unicauca.edu.co', crypt('1234', gen_salt('bf')));
	
	-- Docente
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES ('Carlos', 'Gómez', 'IngenieriaDeSistemas', 'Docente', 'carlos@unicauca.edu.co', crypt('1234', gen_salt('bf')));
	
	-- Coordinador
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES ('Marta', 'Ríos', 'IngenieriaDeSistemas', 'Coordinador', 'marta@unicauca.edu.co', crypt('1234', gen_salt('bf')));
	
	-- Enviar formato A
	SELECT * FROM gtg.submit_formato(
	    NULL,                                   -- NULL = nuevo formato
	    (SELECT id FROM gtg.usuario WHERE correo='juan@unicauca.edu.co'), -- estudiante1
		NULL,
	    (SELECT id FROM gtg.usuario WHERE correo='carlos@unicauca.edu.co'),  -- docente
	    (SELECT id FROM gtg.usuario WHERE correo='carlos@unicauca.edu.co'), -- enviado_por (debe ser uno de los estudiantes)
	    'Sistema de Gestión de TGfff',             -- título
	    'Investigación',                        -- modalidad
	    'Dr. López',                            -- director
	    NULL,                                   -- co-director
	    '2025-09-20',                           -- fecha_presentacion
	    'Objetivo general del proyecto',        -- objetivos_generales
	    'Objetivo específico 1; Objetivo 2',    -- objetivos_especificos
	    '/uploads/formatoA_v1.pdf'              -- archivo_formato_path
	);
	
	-- Reenviar formato A
	SELECT * FROM gtg.submit_formato(
	    (SELECT id FROM gtg.formato LIMIT 1),   -- formato ya existente
	    (SELECT id FROM gtg.usuario WHERE correo='juan@unicauca.edu.co'),
	    NULL,
	    (SELECT id FROM gtg.usuario WHERE correo='carlos@unicauca.edu.co'), 
		(SELECT id FROM gtg.usuario WHERE correo='carlos@unicauca.edu.co'), -- Lo reenvía docente
	    'Sistema de Gestión de TG - corregido2',
	    'Investigación',
	    'Dr. López',
	    NULL,
	    '2025-09-25',
	    'Objetivo general actualizado',
	    'Objetivo específico 1 actualizado',
	    '/uploads/formatoA_v2.pdf'
	);
	
	-- Coordinador evalua formato
	SELECT * FROM gtg.add_evaluacion_coordinador(
	    (SELECT id FROM gtg.formato LIMIT 1),
	    (SELECT id FROM gtg.formato_version ORDER BY version DESC LIMIT 1),
	    (SELECT id FROM gtg.usuario WHERE rol='Coordinador'),
	    'Correcciones',
	    'El título no es claro'
	);
	
	
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES ('11', '0', 'IngenieriaDeSistemas', 'Estudiante', '11', crypt('11', gen_salt('bf')));
	
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES ('2', '0', 'IngenieriaDeSistemas', 'Docente', '2', crypt('2', gen_salt('bf')));
	
	INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
	VALUES ('3', '0', 'IngenieriaDeSistemas', 'Coordinador', '3', crypt('3', gen_salt('bf')));
	
	SELECT * FROM gtg.usuario;
	SELECT * FROM gtg.formato;
	SELECT * FROM gtg.formato_version;
	SELECT * FROM gtg.evaluacion_coordinador;
	
	-- ===============================================
	-- NOTAS:
	-- - gtg_owner: se usa para crear y modificar la estructura de la BD (DDL).
	-- - gtg_appuser: se usa en la aplicación para ejecutar consultas normales (DML).
	-- - Me faltaría agregar un usuario para reportes, pero después.
	-- ===============================================