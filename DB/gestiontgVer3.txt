
-- Eliminar tablas
DROP TABLE IF EXISTS gtg.evaluacion_coordinador CASCADE;
DROP TABLE IF EXISTS gtg.formato_version CASCADE;
DROP TABLE IF EXISTS gtg.formato CASCADE;
DROP TABLE IF EXISTS gtg.usuario CASCADE;

-- Eliminar funciones
DROP FUNCTION IF EXISTS gtg.fn_get_latest_version(UUID);

DROP FUNCTION IF EXISTS gtg.submit_formato(
    UUID, UUID, UUID, UUID, UUID, TEXT, TEXT, TEXT, TEXT, DATE, TEXT, TEXT, TEXT, TEXT,
    OUT UUID, OUT INTEGER
);

DROP FUNCTION IF EXISTS gtg.add_evaluacion_coordinador(
    UUID, UUID, UUID, TEXT, TEXT,
    OUT UUID
); 

--Eliminar indices 
DROP INDEX IF EXISTS gtg.idx_usuario_correo;
DROP INDEX IF EXISTS gtg.idx_formato_est1;
DROP INDEX IF EXISTS gtg.idx_formato_est2;
DROP INDEX IF EXISTS gtg.idx_formato_doc;
DROP INDEX IF EXISTS gtg.idx_formato_estado;
DROP INDEX IF EXISTS gtg.idx_formato_version_formato;
DROP INDEX IF EXISTS gtg.idx_formato_version_formato_version;
DROP INDEX IF EXISTS gtg.idx_eval_formato;
DROP INDEX IF EXISTS gtg.idx_eval_coordinador_coordinador;

-- Limpiar tablas
TRUNCATE TABLE gtg.evaluacion_coordinador RESTART IDENTITY CASCADE;
TRUNCATE TABLE gtg.formato_version RESTART IDENTITY CASCADE;
TRUNCATE TABLE gtg.formato RESTART IDENTITY CASCADE;
TRUNCATE TABLE gtg.usuario RESTART IDENTITY CASCADE;

-- ===============================================
-- USUARIOS Y BASE DE DATOS GTG
-- ===============================================

-- Rol dueño de la BD (solo para DDL, no para la app)
CREATE ROLE gtg_owner LOGIN PASSWORD 'AdminPass2025!' CREATEDB;

-- Base de datos principal
CREATE DATABASE gestiontg OWNER gtg_owner;

-- Rol de la aplicación (solo DML)
CREATE ROLE gtg_appuser LOGIN PASSWORD 'ApplicationUser2025!';

CREATE SCHEMA IF NOT EXISTS gtg AUTHORIZATION gtg_owner;

-- Extensiones
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- ===============================================
-- ASIGNACIÓN DE PRIVILEGIOS AL USUARIO DE LA APP
-- ===============================================
GRANT CONNECT ON DATABASE gestiontg TO gtg_appuser;   -- acceso a la BD
GRANT USAGE ON SCHEMA public TO gtg_appuser;          -- uso de esquema public
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO gtg_appuser; -- DML
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO gtg_appuser;

-- Conceder acceso al esquema gtg
GRANT USAGE ON SCHEMA gtg TO gtg_appuser;

-- Conceder permisos sobre todas las tablas del esquema gtg
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA gtg TO gtg_appuser;

-- Asegurar permisos para tablas futuras
ALTER DEFAULT PRIVILEGES IN SCHEMA gtg 
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO gtg_appuser;

-- Conceder permisos para usar las secuencias (necesario para inserciones con DEFAULT)
GRANT USAGE ON ALL SEQUENCES IN SCHEMA gtg TO gtg_appuser;
ALTER DEFAULT PRIVILEGES IN SCHEMA gtg 
GRANT USAGE ON SEQUENCES TO gtg_appuser;

-- ===============================================
-- CREACIÓN DE TABLAS
-- ===============================================

-- USUARIO (docentes, estudiantes, coordinadores)
CREATE TABLE IF NOT EXISTS gtg.usuario (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),  -- Estaba usando UUID, si resulta cansón lo podemos cambiar.
    nombres TEXT NOT NULL,
    apellidos TEXT NOT NULL,
    celular TEXT,
    programa TEXT NOT NULL CHECK (programa IN 
        ('IngenieriaDeSistemas', 
         'IngenieriaElectronicaYTelecomunicaciones', 
         'AutomaticaIndustrial', 
         'TecnologiaIndustrial')),
    rol TEXT NOT NULL CHECK (rol IN ('Docente', 'Estudiante', 'Coordinador')),
    correo TEXT UNIQUE NOT NULL,
    contrasenia TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_usuario_correo ON gtg.usuario(correo);

-- FORMATO A (Tabla maestra de formato A (Id dijo por cada formato))
CREATE TABLE IF NOT EXISTS gtg.formato (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    estudiante_id1 UUID NOT NULL REFERENCES gtg.usuario(id) ON DELETE CASCADE,
	estudiante_id2 UUID	NULL REFERENCES gtg.usuario(id) ON DELETE SET NULL, --- Cambiar esto
	docente_id UUID NOT NULL REFERENCES gtg.usuario(id) ON DELETE CASCADE,
    titulo TEXT NOT NULL,
    modalidad TEXT NOT NULL,
    director TEXT NOT NULL,
    co_director TEXT,
    fecha_presentacion DATE NOT NULL,
    estado TEXT NOT NULL CHECK (estado IN (
        'EnRevision', 'Aprobado', 'Rechazado', 'CorreccionesSolicitadas'
    )) DEFAULT 'EnRevision',
    intentos INTEGER NOT NULL DEFAULT 0,    -- número de envíos (se controla con funciones)
    max_intentos INTEGER NOT NULL DEFAULT 3,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_formato_est1 ON gtg.formato(estudiante_id1);
CREATE INDEX IF NOT EXISTS idx_formato_est2 ON gtg.formato(estudiante_id2);
CREATE INDEX IF NOT EXISTS idx_formato_doc ON gtg.formato(docente_id);
CREATE INDEX IF NOT EXISTS idx_formato_estado ON gtg.formato(estado);

-- HISTORIAL DE VERSIONES (Cada reenvío genera una nueva fila)
CREATE TABLE IF NOT EXISTS gtg.formato_version (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    formato_id UUID NOT NULL REFERENCES gtg.formato(id) ON DELETE CASCADE,
    version INTEGER NOT NULL, 
    titulo TEXT NOT NULL,
    modalidad TEXT NOT NULL,
    director TEXT NOT NULL,
    co_director TEXT,
    fecha_presentacion DATE NOT NULL,
    objetivos_generales TEXT NOT NULL,
    objetivos_especificos TEXT NOT NULL,
    carta_aceptacion_path TEXT,
    archivo_formato_path TEXT NOT NULL, -- ruta/URL al PDF
    observaciones_estudiante TEXT,
    estado_local TEXT NOT NULL CHECK (estado_local IN (
        'Enviado', 'Corregido'
    )) DEFAULT 'Enviado',
    enviado_por UUID NOT NULL REFERENCES gtg.usuario(id),
    fecha_subida TIMESTAMPTZ DEFAULT now(),
    UNIQUE (formato_id, version)
);

CREATE INDEX IF NOT EXISTS idx_formato_version_formato ON gtg.formato_version(formato_id);
CREATE INDEX IF NOT EXISTS idx_formato_version_formato_version ON gtg.formato_version(formato_id, version DESC);

-- EVALUACIÓN COORDINADOR
CREATE TABLE IF NOT EXISTS gtg.evaluacion_coordinador (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    formato_id UUID NOT NULL REFERENCES gtg.formato(id) ON DELETE CASCADE,
    formato_version_id UUID REFERENCES gtg.formato_version(id) ON DELETE SET NULL,
    coordinador_id UUID NOT NULL REFERENCES gtg.usuario(id),
    decision TEXT NOT NULL CHECK (decision IN ('Aprobado', 'Correcciones', 'Rechazado')),
    comentarios TEXT,
    fecha_evaluacion TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_eval_formato ON gtg.evaluacion_coordinador(formato_id);
CREATE INDEX IF NOT EXISTS idx_eval_coordinador_coordinador ON gtg.evaluacion_coordinador(coordinador_id);

-- ===========================================
-- Función para obtener la última versión de un formato
-- ===========================================
CREATE OR REPLACE FUNCTION gtg.fn_get_latest_version(p_formato_id UUID)
RETURNS INTEGER LANGUAGE sql STABLE AS $$
  SELECT COALESCE(MAX(version), 0) FROM gtg.formato_version WHERE formato_id = p_formato_id;
$$;

-- ===========================================
-- Función para "enviar/reenviar" Formato A (gestiona versión + intentos)
--    - Si p_formato_id IS NULL -> crea formato maestro + version 1
--    - Si p_formato_id IS NOT NULL -> crea nueva versión (version = last+1)
--    - Bloquea si intentos >= max_intentos
-- ===========================================
CREATE OR REPLACE FUNCTION gtg.submit_formato(
    p_formato_id UUID,            -- NULL => crear nuevo
    p_estudiante_id1 UUID,
    p_estudiante_id2 UUID,
    p_docente_id UUID,
    p_enviado_por UUID,
    p_titulo TEXT,
    p_modalidad TEXT,
    p_director TEXT,
    p_co_director TEXT,
    p_fecha_presentacion DATE,
    p_objetivos_generales TEXT,
    p_objetivos_especificos TEXT,
    p_carta_aceptacion_path TEXT,
    p_archivo_formato_path TEXT,
    OUT o_formato_id UUID,
    OUT o_version INTEGER
) RETURNS RECORD
LANGUAGE plpgsql AS $$
DECLARE
    v_formato gtg.formato%ROWTYPE;
    v_next_version INTEGER;
BEGIN
    IF p_formato_id IS NULL THEN
        -- ===== CREAR NUEVO FORMATO =====
        PERFORM 1 FROM gtg.usuario WHERE id = p_estudiante_id1;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Estudiante1 no existe';
        END IF;

        IF p_estudiante_id2 IS NOT NULL THEN
            PERFORM 1 FROM gtg.usuario WHERE id = p_estudiante_id2;
            IF NOT FOUND THEN
                RAISE EXCEPTION 'Estudiante2 informado no existe';
            END IF;
        END IF;

        -- validar que p_enviado_por sea el docente
        IF p_enviado_por IS NULL OR (p_enviado_por <> p_docente_id) THEN
            RAISE EXCEPTION 'El formato A debe ser enviado por el docente.';
        END IF;

        -- crear formato maestro
        INSERT INTO gtg.formato (estudiante_id1, estudiante_id2, docente_id, titulo, modalidad, director, co_director, fecha_presentacion, estado, intentos, max_intentos, created_at, updated_at)
        VALUES (p_estudiante_id1, p_estudiante_id2, p_docente_id, p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion, 'EnRevision', 1, 3, now(), now())
        RETURNING * INTO v_formato;

        v_next_version := 1;

        -- primera versión
        INSERT INTO gtg.formato_version (formato_id, version, titulo, modalidad, director, co_director, fecha_presentacion,
            objetivos_generales, objetivos_especificos, carta_aceptacion_path, archivo_formato_path, estado_local, enviado_por, fecha_subida)
        VALUES (v_formato.id, v_next_version, p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion,
            p_objetivos_generales, p_objetivos_especificos, p_carta_aceptacion_path, p_archivo_formato_path, 'Enviado', p_enviado_por, now());

        o_formato_id := v_formato.id;
        o_version := v_next_version;
        RETURN;

    ELSE
        -- ===== REENVÍO =====
        SELECT * INTO v_formato FROM gtg.formato WHERE id = p_formato_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'Formato % no encontrado', p_formato_id;
        END IF;

        -- validar que p_enviado_por sea el docente del formato
        IF p_enviado_por IS NULL OR (p_enviado_por <> v_formato.docente_id) THEN
            RAISE EXCEPTION 'Solo el docente propietario puede reenviar el formato.';
        END IF;

        -- bloquear si el estado no es CorreccionesSolicitadas
        IF v_formato.estado <> 'CorreccionesSolicitadas' THEN
            RAISE EXCEPTION 'El formato solo puede reenviarse cuando el estado es "CorreccionesSolicitadas". Estado actual: %', v_formato.estado;
        END IF;

        -- bloquear si ya alcanzó el máximo de intentos
        IF v_formato.intentos >= v_formato.max_intentos THEN
            UPDATE gtg.formato
            SET estado = 'Rechazado',
                updated_at = now()
            WHERE id = p_formato_id;
            RAISE EXCEPTION 'Se alcanzó el máximo de intentos (%). El formato ha sido rechazado.', v_formato.max_intentos;
        END IF;

        -- calcular siguiente versión
        v_next_version := (SELECT COALESCE(MAX(version),0) + 1 FROM gtg.formato_version WHERE formato_id = p_formato_id);

        -- insertar nueva versión
        INSERT INTO gtg.formato_version (formato_id, version, titulo, modalidad, director, co_director, fecha_presentacion,
            objetivos_generales, objetivos_especificos, carta_aceptacion_path, archivo_formato_path, estado_local, enviado_por, fecha_subida)
        VALUES (p_formato_id, v_next_version, p_titulo, p_modalidad, p_director, p_co_director, p_fecha_presentacion,
            p_objetivos_generales, p_objetivos_especificos, p_carta_aceptacion_path, p_archivo_formato_path, 'Corregido', p_enviado_por, now());

        -- incrementar contador y mantener estado en revisión
        UPDATE gtg.formato
        SET intentos = intentos + 1,
            estado = CASE 
                        WHEN intentos + 1 > max_intentos THEN 'Rechazado'
                        ELSE 'EnRevision'
                     END,
            updated_at = now(),
            titulo = p_titulo,
            modalidad = p_modalidad,
            director = p_director,
            co_director = p_co_director,
            fecha_presentacion = p_fecha_presentacion
        WHERE id = p_formato_id
        RETURNING * INTO v_formato;
		

        -- si llegó al límite, cerramos el caso
        IF v_formato.estado = 'Rechazado' THEN
            RAISE EXCEPTION 'El formato ha sido rechazado definitivamente tras alcanzar el máximo de intentos.';
        END IF;

        o_formato_id := v_formato.id;
        o_version := v_next_version;
        RETURN;
    END IF;
END;
$$;

-- ===================================
-- Función: add_evaluacion_coordinador (coordinador evalúa)
-- ===================================
CREATE OR REPLACE FUNCTION gtg.add_evaluacion_coordinador(
    p_formato_id UUID,
    p_formato_version_id UUID,
    p_coordinador_id UUID,
    p_decision TEXT,
    p_comentarios TEXT,
    OUT o_eval_id UUID
) RETURNS UUID
LANGUAGE plpgsql AS $$
DECLARE
    v_rol TEXT;
BEGIN
    -- validar rol del coordinador
    SELECT rol INTO v_rol FROM gtg.usuario WHERE id = p_coordinador_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Coordinador con id % no encontrado', p_coordinador_id;
    END IF;
    IF v_rol <> 'Coordinador' THEN
        RAISE EXCEPTION 'Usuario % no tiene rol Coordinador', p_coordinador_id;
    END IF;

    -- validar existencia del formato maestro
    PERFORM 1 FROM gtg.formato WHERE id = p_formato_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Formato % no existe', p_formato_id;
    END IF;

    -- si se pasó formato_version_id, validar que pertenezca al formato
    IF p_formato_version_id IS NOT NULL THEN
        PERFORM 1 FROM gtg.formato_version fv
        WHERE fv.id = p_formato_version_id AND fv.formato_id = p_formato_id;
        IF NOT FOUND THEN
            RAISE EXCEPTION 'La versión % no pertenece al formato %', p_formato_version_id, p_formato_id;
        END IF;
    END IF;

    -- validar decisión permitida (seguridad extra)
    IF p_decision NOT IN ('Aprobado','Correcciones','Rechazado') THEN
        RAISE EXCEPTION 'Decision inválida: %', p_decision;
    END IF;

    -- insertar evaluación y devolver id en la variable OUT
    INSERT INTO gtg.evaluacion_coordinador (formato_id, formato_version_id, coordinador_id, decision, comentarios, fecha_evaluacion)
    VALUES (p_formato_id, p_formato_version_id, p_coordinador_id, p_decision, p_comentarios, now())
    RETURNING id INTO o_eval_id;

    -- actualizar estado del maestro según la decisión
    IF p_decision = 'Aprobado' THEN
        UPDATE gtg.formato SET estado = 'Aprobado', updated_at = now() WHERE id = p_formato_id;
    ELSIF p_decision = 'Rechazado' THEN
        UPDATE gtg.formato SET estado = 'Rechazado', updated_at = now() WHERE id = p_formato_id;
    ELSIF p_decision = 'Correcciones' THEN
        UPDATE gtg.formato SET estado = 'CorreccionesSolicitadas', updated_at = now() WHERE id = p_formato_id;
    END IF;

    RETURN;  -- RECORDAAAR: en funciones con OUT usar RETURN sin valor
END;
$$;

-- ===============================================
-- PRUEBAS
-- ===============================================
-- Estudiantes
INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
VALUES 
('Juan', 'Pérez', 'IngenieriaDeSistemas', 'Estudiante', 'juan@correo.com', crypt('1234', gen_salt('bf'))),
('Ana', 'López', 'IngenieriaDeSistemas', 'Estudiante', 'ana@correo.com', crypt('1234', gen_salt('bf')));

-- Docente
INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
VALUES ('Carlos', 'Gómez', 'IngenieriaDeSistemas', 'Docente', 'carlos@correo.com', crypt('1234', gen_salt('bf')));

-- Coordinador
INSERT INTO gtg.usuario (nombres, apellidos, programa, rol, correo, contrasenia)
VALUES ('Marta', 'Ríos', 'IngenieriaDeSistemas', 'Coordinador', 'marta@correo.com', crypt('1234', gen_salt('bf')));

-- Enviar formato A
SELECT * FROM gtg.submit_formato(
    NULL,                                   -- NULL = nuevo formato
    (SELECT id FROM gtg.usuario WHERE correo='juan@correo.com'), -- estudiante1
	NULL,
    (SELECT id FROM gtg.usuario WHERE correo='carlos@correo.com'),  -- docente
    (SELECT id FROM gtg.usuario WHERE correo='carlos@correo.com'), -- enviado_por (debe ser uno de los estudiantes)
    'Sistema de Gestión de TG',             -- título
    'Investigación',                        -- modalidad
    'Dr. López',                            -- director
    NULL,                                   -- co-director
    '2025-09-20',                           -- fecha_presentacion
    'Objetivo general del proyecto',        -- objetivos_generales
    'Objetivo específico 1; Objetivo 2',    -- objetivos_especificos
    NULL,                                   -- carta_aceptacion_path
    '/uploads/formatoA_v1.pdf'              -- archivo_formato_path
);

-- Reenviar formato A
SELECT * FROM gtg.submit_formato(
    (SELECT id FROM gtg.formato LIMIT 1),   -- formato ya existente
    (SELECT id FROM gtg.usuario WHERE correo='juan@correo.com'),
    NULL,
    (SELECT id FROM gtg.usuario WHERE correo='carlos@correo.com'), 
	(SELECT id FROM gtg.usuario WHERE correo='carlos@correo.com'), -- Lo reenvía docente
    'Sistema de Gestión de TG - corregido2',
    'Investigación',
    'Dr. López',
    NULL,
    '2025-09-25',
    'Objetivo general actualizado',
    'Objetivo específico 1 actualizado',
    NULL,
    '/uploads/formatoA_v2.pdf'
);

-- Coordinador evalua formato
SELECT * FROM gtg.add_evaluacion_coordinador(
    (SELECT id FROM gtg.formato LIMIT 1),
    (SELECT id FROM gtg.formato_version ORDER BY version DESC LIMIT 1),
    (SELECT id FROM gtg.usuario WHERE rol='Coordinador'),
    'Correcciones',
    'El título no es claro'
);


SELECT * FROM gtg.usuario;
SELECT * FROM gtg.formato;
SELECT * FROM gtg.formato_version;
SELECT * FROM gtg.evaluacion_coordinador;

-- ===============================================
-- NOTAS:
-- - gtg_owner: se usa para crear y modificar la estructura de la BD (DDL).
-- - gtg_appuser: se usa en la aplicación para ejecutar consultas normales (DML).
-- - Me faltaría agregar un usuario para reportes, pero después.
-- ===============================================